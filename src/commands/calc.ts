/**
 * Batch-upgrade placeholder `calc.js` files under generated meta output.
 *
 * Why:
 * - `gen` focuses on producing static meta; calc.js generation is optional and may be slow (LLM).
 * - For weak/slow free-tier models, it's better to run a dedicated command that can be resumed.
 *
 * What it does:
 * - Scan `meta-{gs|sr}/character` recursively and find `calc.js`
 * - If it is a placeholder, generate a minimal usable calc.js:
 *   - Prefer LLM (OpenAI-compatible) when configured
 *   - Fall back to heuristic when LLM is unavailable
 */

import fs from 'node:fs'
import path from 'node:path'
import { walkFiles } from '../fs/walk.js'
import { loadToolConfig } from '../config/config.js'
import { tryCreateLlmService } from '../llm/try-create.js'
import { buildCalcJsWithChannel, normalizeCalcChannel } from '../generate/calc/build.js'
import { calcCreatedBy } from '../generate/calc/llm-calc.js'
import { runPromisePool } from '../utils/promise-pool.js'
import type { CommandContext, GenOptions, Game } from '../types.js'
import { resolveRepoPath } from '../utils/resolve-path.js'

function isRecord(v: unknown): v is Record<string, unknown> {
  return typeof v === 'object' && v !== null && !Array.isArray(v)
}

function normalizeTextInline(text: unknown): string {
  if (typeof text !== 'string') return ''
  return text
    .replace(/<[^>]+>/g, '')
    .replaceAll('\\n', ' ')
    .replaceAll('\n', ' ')
    .replace(/\s+/g, ' ')
    .trim()
}

function inferUnitHintFromTableValues(valuesRaw: unknown): string {
  const values = Array.isArray(valuesRaw) ? valuesRaw : []
  for (const v of values.slice(0, 3)) {
    const t = normalizeTextInline(v)
    if (!t) continue
    if (/(元素精通|精通|mastery|elemental mastery|\bem\b)/i.test(t)) return '元素精通'
    if (/(生命值上限|最大生命值|生命值|\bhp\b)/i.test(t)) return '生命值上限'
    if (/(防御力|防御|\bdef\b)/i.test(t)) return '防御力'
    if (/(攻击力|攻击|\batk\b)/i.test(t)) return '攻击力'
  }
  return ''
}

function isPlaceholderCalc(filePath: string): boolean {
  try {
    const raw = fs.readFileSync(filePath, 'utf8')
    return raw.includes('Auto-generated placeholder')
  } catch {
    return false
  }
}

function isAutoGeneratedCalcRaw(raw: string): boolean {
  // Our generator always emits this header.
  return raw.includes('// Auto-generated by ')
}

function hasEmptyBuffsRaw(raw: string): boolean {
  return /export const buffs\s*=\s*\[\s*]/.test(raw)
}

function isOutdatedAutoGeneratedCalcRaw(raw: string, expectedCreatedBy: string): boolean {
  if (!isAutoGeneratedCalcRaw(raw)) return false
  // Bump createdBy when generator semantics change so `calc` can upgrade deterministically without `--force`.
  // NOTE: expected signature depends on the configured calc channel (llm vs upstream-follow).
  return !raw.includes(`export const createdBy = ${JSON.stringify(expectedCreatedBy)}`)
}

function isValidCalcJsRaw(raw: string): boolean {
  // Similar to the runtime import check in miao-plugin, but kept local/fast:
  // - catches SyntaxError (bad tokens / unbalanced parens)
  // - catches top-level ReferenceError (e.g. `params.xxx` evaluated at module load)
  try {
    const body = raw.replace(/^\s*export\s+const\s+/gm, 'const ')
    // eslint-disable-next-line no-new-func
    const fn = new Function(body)
    fn()
    return true
  } catch {
    return false
  }
}

function metaGameDir(root: string, game: Game): string {
  return path.join(root, `meta-${game}`)
}

type CalcTables = Record<string, string[]>

function getGsTables(meta: Record<string, unknown>): CalcTables | null {
  const talentData = isRecord(meta.talentData) ? (meta.talentData as Record<string, unknown>) : null
  if (!talentData) return null
  const get = (k: 'a' | 'e' | 'q'): string[] => {
    const blk = talentData[k]
    if (!isRecord(blk)) return []
    return Object.keys(blk).filter(Boolean)
  }
  const a = get('a')
  const e = get('e')
  const q = get('q')
  if (a.length === 0 && e.length === 0 && q.length === 0) return null
  return { a, e, q }
}

function getSrTables(meta: Record<string, unknown>): CalcTables | null {
  const talent = isRecord(meta.talent) ? (meta.talent as Record<string, unknown>) : null
  if (!talent) return null

  const out: CalcTables = {}
  for (const [k, blk] of Object.entries(talent)) {
    if (!isRecord(blk)) continue
    const tablesRaw = (blk as Record<string, unknown>).tables
    const names: string[] = []
    if (Array.isArray(tablesRaw)) {
      for (const t of tablesRaw) {
        if (isRecord(t) && typeof t.name === 'string') names.push((t.name as string).trim())
      }
    } else if (isRecord(tablesRaw)) {
      for (const t of Object.values(tablesRaw)) {
        if (isRecord(t) && typeof t.name === 'string') names.push((t.name as string).trim())
      }
    }
    const list = names.filter(Boolean)
    if (list.length) out[k] = list
  }
  return Object.keys(out).length ? out : null
}

function buildBuffHints(game: Game, meta: Record<string, unknown>): string[] {
  const hints: string[] = []

  if (game === 'gs') {
    const isCombatLike = (s: string): boolean =>
      /(伤害|攻击|防御|生命|暴击|元素|精通|充能|治疗|护盾|抗性|穿透|提高|提升|降低|增加|减少|\d|%)/.test(s)
    const isNonCombat = (s: string): boolean => {
      // Avoid dropping combat passives that happen to mention skill names like "低温烹饪".
      if (/(探索派遣|派遣任务|采集|钓鱼)/.test(s)) return true
      // Typical truly non-combat passives: "完美烹饪/合成/锻造/制作/加工...时..."
      if (/(完美|额外).{0,8}(烹饪|合成|制作|锻造|加工)/.test(s)) return true
      if (/(烹饪|合成|制作|锻造|加工).{0,8}(时|后)/.test(s) && !isCombatLike(s)) return true
      return false
    }

    const passiveRaw = Array.isArray(meta.passive) ? (meta.passive as Array<unknown>) : []
    for (const p of passiveRaw) {
      if (!isRecord(p)) continue
      const name = typeof p.name === 'string' ? (p.name as string).trim() : ''
      const descArr = Array.isArray(p.desc) ? (p.desc as Array<unknown>) : []
      const desc = descArr.filter((x) => typeof x === 'string').join(' ').trim()
      if (!name || !desc) continue
      if (isNonCombat(desc)) continue
      if (!isCombatLike(desc)) continue
      hints.push(`被动：${name}：${desc}`)
    }

    const consRaw = isRecord(meta.cons) ? (meta.cons as Record<string, unknown>) : null
    if (consRaw) {
      const keys = Object.keys(consRaw)
        .map((k) => Number(k))
        .filter((n) => Number.isFinite(n))
        .sort((a, b) => a - b)
      for (const n of keys) {
        const c = consRaw[String(n)]
        if (!isRecord(c)) continue
        const name = typeof c.name === 'string' ? (c.name as string).trim() : ''
        const descArr = Array.isArray(c.desc) ? (c.desc as Array<unknown>) : []
        const desc = descArr.filter((x) => typeof x === 'string').join(' ').trim()
        if (!name || !desc) continue
        if (!isCombatLike(desc)) continue
        hints.push(`${n}命：${name}：${desc}`)
      }
    }
  } else if (game === 'sr') {
    const isSrTechniqueBuffLike = (desc: string): boolean =>
      /(提高|提升|增加|降低|减少|加成)/.test(desc) &&
      /(攻击力|防御力|生命值上限|生命值|速度|暴击率|暴击伤害|伤害|受到.{0,6}伤害|击破|效果命中|效果抵抗|无视|穿透|抗性)/.test(desc)

    const talent = isRecord(meta.talent) ? (meta.talent as Record<string, unknown>) : null
    const z = talent && isRecord(talent.z) ? (talent.z as Record<string, unknown>) : null
    if (z) {
      const name = typeof z.name === 'string' ? (z.name as string).trim() : ''
      const descRaw = typeof z.desc === 'string' ? (z.desc as string) : ''
      const desc = normalizeTextInline(descRaw)
      if (name && desc && isSrTechniqueBuffLike(desc)) hints.push(`秘技：${name}：${desc}`)
    }

    const consRaw = isRecord(meta.cons) ? (meta.cons as Record<string, unknown>) : null
    if (consRaw) {
      const keys = Object.keys(consRaw)
        .map((k) => Number(k))
        .filter((n) => Number.isFinite(n))
        .sort((a, b) => a - b)
      for (const n of keys) {
        const c = consRaw[String(n)]
        if (!isRecord(c)) continue
        const name = typeof c.name === 'string' ? (c.name as string).trim() : ''
        const desc = typeof c.desc === 'string' ? (c.desc as string).trim() : ''
        if (!name || !desc) continue
        hints.push(`${n}魂：${name}：${desc}`)
      }
    }

    const treeData = isRecord(meta.treeData) ? (meta.treeData as Record<string, unknown>) : null
    if (treeData) {
      const nodes: Array<{ idx: number; name: string; desc: string }> = []
      for (const v of Object.values(treeData)) {
        if (!isRecord(v)) continue
        if (v.type !== 'skill' || v.root !== true) continue
        const idx = typeof v.idx === 'number' && Number.isFinite(v.idx) ? Math.trunc(v.idx) : 0
        const name = typeof v.name === 'string' ? (v.name as string).trim() : ''
        const desc = typeof v.desc === 'string' ? (v.desc as string).trim() : ''
        if (!idx || !name || !desc) continue
        nodes.push({ idx, name, desc })
      }
      nodes.sort((a, b) => a.idx - b.idx)
      for (const n of nodes) {
        hints.push(`行迹${n.idx}：${n.name}：${n.desc}`)
      }
    }
  }

  return hints
}

export async function calcCommand(ctx: CommandContext, options: GenOptions): Promise<void> {
  const outputRoot = resolveRepoPath(ctx, options.outputRoot)
  const games = options.games
  ctx.log.info(`[meta-gen] calc: outputRoot=${outputRoot} games=${games.join(',')}`)

  const toolConfig = loadToolConfig(ctx.projectRoot) ?? undefined
  const calcChannel = normalizeCalcChannel(toolConfig?.calc?.channel)
  const expectedCreatedBy = calcCreatedBy(calcChannel)
  const needsLlm = calcChannel !== 'upstream-direct'
  let llm = needsLlm ? tryCreateLlmService(ctx, toolConfig, { purpose: 'calc' }) : undefined
  const llmCacheRootAbs = path.join(ctx.projectRoot, '.cache', 'llm')

  // Fast-fail / protect outputs:
  // - When user passes `--force`, this command may overwrite many existing calc.js files.
  // - If LLM auth/config is broken (e.g. invalid API key), we must NOT silently downgrade to heuristic.
  if (llm) {
    try {
      await llm.chat([{ role: 'user', content: 'ping' }], { temperature: 0, maxTokens: 4 })
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e)
      if (options.force) {
        throw new Error(
          `[meta-gen] calc: LLM preflight failed; refusing to run with --force (would overwrite with heuristic). ${msg}`
        )
      }
      ctx.log.warn(`[meta-gen] calc: LLM preflight failed, disabling LLM and using heuristic: ${msg}`)
      llm = undefined
    }
  }

  let upgraded = 0
  let scanned = 0

  type Job = { game: Game; filePath: string }
  const jobs: Job[] = []

  for (const game of games) {
    const charRoot = path.join(metaGameDir(outputRoot, game), 'character')
    if (!fs.existsSync(charRoot)) continue

    for await (const filePath of walkFiles(charRoot, { ignoreNames: new Set(['.ace-tool']) })) {
      if (path.basename(filePath) !== 'calc.js') continue

      scanned++
      let calcRaw = ''
      try {
        calcRaw = fs.readFileSync(filePath, 'utf8')
      } catch {
        continue
      }

      const isPlaceholder = calcRaw.includes('Auto-generated placeholder')
      const isAutoGenerated = isAutoGeneratedCalcRaw(calcRaw)
      const isInvalid = isAutoGenerated && !isValidCalcJsRaw(calcRaw)
      const isOutdated = isAutoGenerated && isOutdatedAutoGeneratedCalcRaw(calcRaw, expectedCreatedBy)
      const shouldUpgrade =
        isPlaceholder ||
        isInvalid ||
        isOutdated ||
        (isAutoGenerated && hasEmptyBuffsRaw(calcRaw)) ||
        (options.force && isAutoGenerated)

      if (!shouldUpgrade) continue
      jobs.push({ game, filePath })
    }
  }

  const concurrency = llm ? Math.max(4, Math.floor((toolConfig?.llm?.maxConcurrency || 1) * 1.5)) : 16

  await runPromisePool(jobs, concurrency, async ({ game, filePath }) => {
    const dir = path.dirname(filePath)
    const dataPath = path.join(dir, 'data.json')
    if (!fs.existsSync(dataPath)) return

    let metaRaw: unknown
    try {
      metaRaw = JSON.parse(fs.readFileSync(dataPath, 'utf8'))
    } catch (e) {
      ctx.log.warn(`[meta-gen] calc: failed to parse ${dataPath}: ${String(e)}`)
      return
    }
    if (!isRecord(metaRaw)) return

    const name = typeof metaRaw.name === 'string' ? (metaRaw.name as string) : path.basename(dir)
    const elem = typeof metaRaw.elem === 'string' ? (metaRaw.elem as string) : ''
    const weapon = typeof metaRaw.weapon === 'string' ? (metaRaw.weapon as string) : ''
    const star = typeof metaRaw.star === 'number' && Number.isFinite(metaRaw.star) ? (metaRaw.star as number) : 0

	    const tables = game === 'gs' ? getGsTables(metaRaw) : game === 'sr' ? getSrTables(metaRaw) : null
	    if (!tables) return

	    const talentDesc: Record<string, string> = {}
	    const tableUnits: Record<string, Record<string, string>> = {}
	    const tableSamples: Record<string, Record<string, unknown>> = {}
	    const tableTextSamples: Record<string, Record<string, string>> = {}
	    const tableTextByName: Record<string, Record<string, string>> = {}
	    const talentRaw = isRecord(metaRaw.talent) ? (metaRaw.talent as Record<string, unknown>) : null
	    if (talentRaw) {
	      for (const k of Object.keys(tables)) {
	        const blk = talentRaw[k]
	        if (!isRecord(blk)) continue
        const desc = (blk as Record<string, unknown>).desc
        if (typeof desc === 'string') talentDesc[k] = desc
        else if (Array.isArray(desc)) talentDesc[k] = desc.filter((x) => typeof x === 'string').join('\n')

	        const tablesRaw = (blk as Record<string, unknown>).tables
	        const outUnits: Record<string, string> = {}
	        const outText: Record<string, string> = {}
	        const pushTable = (t: unknown): void => {
	          if (!isRecord(t)) return
	          const name = typeof t.name === 'string' ? t.name.trim() : ''
	          if (!name || name in outUnits) return
	          let unit = typeof t.unit === 'string' ? t.unit : ''
	          unit = unit.trim()
	          if (!unit) unit = inferUnitHintFromTableValues((t as any).values)
	          outUnits[name] = unit

	          const values = (t as any).values
	          if (Array.isArray(values) && values.length) {
	            const v0 = values[0]
	            const sampleText = normalizeTextInline(v0)
	            if (sampleText) outText[name] = sampleText
	          }
	        }
	        if (Array.isArray(tablesRaw)) {
	          for (const t of tablesRaw) pushTable(t)
	        } else if (isRecord(tablesRaw)) {
	          for (const t of Object.values(tablesRaw)) pushTable(t)
	        }
	        if (Object.keys(outUnits).length) tableUnits[k] = outUnits
	        if (Object.keys(outText).length) tableTextByName[k] = outText
	      }
	    }

    // Provide sample values to help the LLM and post-processing.
    // - Prefer non-scalar tables (arrays/objects) for schema inference.
    // - Keep a few scalar tables with extra semantics (e.g. hit counts) to derive multi-hit totals.
	    const talentDataRaw = isRecord(metaRaw.talentData) ? (metaRaw.talentData as Record<string, unknown>) : null
	    if (talentDataRaw) {
	      for (const k of Object.keys(tables)) {
	        const blk = talentDataRaw[k]
	        if (!isRecord(blk)) continue
	        const out: Record<string, unknown> = {}
	        const outText: Record<string, string> = {}
	        for (const [name, values] of Object.entries(blk)) {
	          if (typeof name !== 'string' || !name.trim()) continue
	          if (!Array.isArray(values) || values.length === 0) continue
	          const sample = values[0]
	          if (Array.isArray(sample) || (sample && typeof sample === 'object')) {
	            out[name] = sample

	            const textMap = tableTextByName[k]
	            if (textMap) {
	              const baseName = name.endsWith('2') ? name.slice(0, -1) : name
	              const txt = textMap[name] || textMap[baseName] || ''
	              if (txt) outText[name] = txt
	            }
	          } else if (typeof sample === 'number' && Number.isFinite(sample)) {
	            // Hit count tables are scalar but critical for deriving "total damage" rows (e.g. Q total hits).
	            if (!/(攻击次数|命中次数|攻击段数)/.test(name)) continue
	            const n = Math.trunc(sample)
	            if (n < 2 || n > 60) continue
	            out[name] = n
	          }
	        }

	        // Also provide text samples for scalar tables that carry extra semantics (multi-hit `*2`, mixed parts `+`),
	        // so the LLM can avoid picking wrong `...2` variants.
	        const textMapAll = tableTextByName[k]
	        if (textMapAll) {
	          for (const [name, txt] of Object.entries(textMapAll)) {
	            if (!name || typeof txt !== 'string') continue
	            const t = txt.trim()
	            if (!t) continue
	            if (!/[*+]/.test(t)) continue
	            if (!(name in outText)) outText[name] = t
	          }
	        }
	        if (Object.keys(out).length) tableSamples[k] = out
	        if (Object.keys(outText).length) tableTextSamples[k] = outText
	      }
	    }

    const id = typeof (metaRaw as any).id === 'number' && Number.isFinite((metaRaw as any).id) ? Math.trunc((metaRaw as any).id) : undefined

    const { js, usedLlm, error } = await buildCalcJsWithChannel({
      llm,
      channel: calcChannel,
      projectRootAbs: ctx.projectRoot,
      upstream: toolConfig?.calc?.upstream,
      input: {
        game,
        id,
        name,
        elem,
        weapon,
        star,
        tables: tables as any,
        tableUnits: tableUnits as any,
        tableSamples: tableSamples as any,
        tableTextSamples: tableTextSamples as any,
        talentDesc: talentDesc as any,
        buffHints: buildBuffHints(game, metaRaw)
      },
      cache: { cacheRootAbs: llmCacheRootAbs, force: options.forceCache }
    })

    if (error) {
      ctx.log.warn(`[meta-gen] calc plan failed (${game} ${name}), using heuristic: ${error}`)
    } else if (usedLlm) {
      ctx.log.info(`[meta-gen] calc generated with LLM: ${game} ${name}`)
    }

    try {
      fs.writeFileSync(filePath, js, 'utf8')
      upgraded++
      if (upgraded === 1 || upgraded % 20 === 0) {
        ctx.log.info(`[meta-gen] calc upgraded: ${upgraded}/${jobs.length} (scanned=${scanned})`)
      }
    } catch (e) {
      ctx.log.warn(`[meta-gen] calc: failed to write ${filePath}: ${String(e)}`)
    }
  })

  ctx.log.info(`[meta-gen] calc done: upgraded=${upgraded} scanned=${scanned}`)
}
